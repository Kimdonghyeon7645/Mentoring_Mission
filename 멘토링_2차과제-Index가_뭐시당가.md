시작에 앞서서 캐럿 프로젝트때 선배가 해주신 리뷰중, index 관련해서 알아보라고 했는데,
알아봐야지 하다가 오늘이 됬습니다... (반성하겠습니다 ㅎㅎ;;)

# Index?

결론적으론, DB 테이블의 검색 속도를 향상시켜주는 자료구조다. 

> 생각해보자, 
>
> 우리가 책에서 원하는 내용을 찾을때, 처음부터 살펴볼때도 있지만, 
> 1000페이지가 넘는 두꺼운 책들도 첫페이지부터 찾아보는 사람은 없을 것이다. 
> 걍 책의 앞장에 있는 목차를 보고, 해당 페이지로 넘어가면 되기 때문이다.
>
> DB도 마찬가지다.
> 테이블의 모든 행을 모두 찾아볼 필요없이, 목차를 사용해 원하는 행을 쉽게 찾을 수 있다. (물론 목차도 목차 나름이다.)
> 이게 **인덱스**다.

한마디로 **DB에서 인덱스**는 테이블에 사용되는 **목차**다.

---

## 1. RDB에서 Clustered Index, Non-clustered Index에 대해서

관계형 데이터베이스(RDB)에서 **Clustered Index, Non-clustered Index** 란 무엇일까?

인덱스는 테이블에서 데이터를 찾을 때 사용하는 목차라고 했었는데,  
이 목차의 구조(=아키텍쳐)에 따라서, **Clustered Index, Non-clustered Index**, 2가지로 나누어 부르는 것이다.

###### InnoDB (MySQL)은 디스크에 데이터를 저장하는 기본 단위를 페이지라고 하며, **인덱스도 페이지 단위로 관리**된다. 그림은 페이지 단위로 관리되는 테이블에서 어떻게 인덱스로 데이터를 참조하는지를 나타낸다.

- **Clustered Index** (클러스터 인덱스)
  ![img](https://t1.daumcdn.net/cfile/tistory/265E6C3951C7F4460C)
  **클러스터 인덱스**는, 이걸 기준으로 실제 테이블의 데이터도 항상 정렬된 상태를 유지한다.
  그러면 우리가 사전에서 가나다 순으로 단어를 찾듯이, 데이터도 위의 사진처럼 검색한다.

  실제 데이터는 이래저래 정렬을 바꿀 수 있는게 아니여서, 이 **클러스터 인덱스**는 테이블마다 1개씩 존재한다. 

   

- **Non-clustered Index** (논클러스터 인덱스)
  ![image](https://user-images.githubusercontent.com/48408417/97179634-620a0580-17dc-11eb-9100-11b0e2493eb4.png)
  **논클러스터 인덱스**는, 실제 테이블의 데이터를 건들지는 않고, 따로 별도의 공간에 인덱스를 만들어 데이터를 정렬한다.

  실제 데이터는 건들지 않아서, 한 테이블에 여러개(최대 249개)씩 존재할 수 있다.

  ```markdown
  몇몇 책의 뒷장에는 '찾아보기'라는 것이 있는데,  
  이게 논클러스터 인덱스와 똑같은 원리다.
  
  찾아보기에서, 원하는 단어가 몇 페이지에 있다고 하면, 실제로 그 단어와 연결되는 페이지로 들어가듯이,  
  데이터베이스에서 논클러스터 인덱스가 있다면, 그걸 기준으로 그 인덱스와 연결되는 인덱스 테이블로 걸려지고,  
  그 인덱스 테이블에서 찾고자 하는 데이터를 찾는다.
  ```

  - 논클러스터 인덱스 종류
    - 단일 인덱스 : 하나의 컬럼을 인덱스로
    - 복합 인덱스 : 여러개의 컬럼을 인덱스로

- 한 테이블에 클러스터와 논클러스터 인덱스를 혼합한 **혼합 인덱스** 도 가능

  

## 2. 본인이 써왔던 RDB에서, 각각이 어떤 구성요소에 해당되는지

- MySQL에서 **클러스터 인덱스** 사용법

  - PK(Primary Key)

  - UNIQUE Not Null 키

    두가지가 있으면 그걸로 자동 생성되며,
    두개가 동시에 있다면, PK를 **클러스터 인덱스**로 사용한다.

    ```mysql
    alter table mixedTbl
        add constraint PK_mixedTbl_userID
            primary key (userID);	-- PK 지정시 클러스터 인덱스 생성
    
      DROP INDEX PRIMARY ON table_name	-- 클러스터 인덱스 삭제
        alter table mixedTbl
            drop primary key;	-- 클러스터 인덱스(pk)를 삭제하려면 반드시 보조(논클러스터) 인덱스를 삭제해야 함
    ```
    
    

- MySQL에서 **논클러스터 인덱스**(=**Secondary Index, 보조 인덱스**) 사용법

  - UNIQUE 키

    가 있으면 그걸로 자동 생성되며,

    ```mysql
    alter table mixedTbl
        add constraint UK_mixedTbl_name
            unique (name);	-- UNIQUE 키 지정시 보조(논클러스터) 인덱스 생성

    CREATE INDEX index_name ON table_name (column_list)	-- 인덱스 생성
    DROP INDEX index_name on table_name	-- 인덱스 삭제
    ```
    
    처럼 직접 인덱스를 생성, 삭제할 수 있다.
    
    

## 3. 이런 Index 개념이 read 성능을 빠르게 만들어주는 이유가 무엇인지

SELECT 의 WHERE 절에 인덱스가 사용될 경우, 조회 성능을 향상시킨다.

그 이유는 앞에서 설명했듯, 책에서 원하는 내용을 찾을때 책 페이지가 클 경우, 첫페이지부터 한장씩 넘기면서 찾는 것보다는, 
목차를 사용해서 원하는 페이지로 바로 넘기여서 찾는게 훨씬 빠른 것처럼,
테이블도 **처음부터 모든 행을 스캔(Full Scan)**하는 것보단, 목차와도 같은 인덱스를 활용해 바로 들어가는 것이 빠르다.



## 4. Index가 read 성능을 늘리지만 손해에는, 어떤 tradeoff가 있는지

결론부터 말하면, 인덱스가 많으면 무조건 성능이 좋아지는 것이 아니다.

**INDEX 장점**

- SELECT에서 인덱스를 WHERE 절에 이용해 데이터를 빠르게 가져올 수 있다.
- 전체 데이터 중 10~15% 내의 데이터를 가져오고자 할 때 가장 유리하다.

**INDEX 단점**

- 저장 공간을 차지 한다. (DB의 10%정도를 index에서 사용)
- 처음 인덱스를 생성하는데 시간이 소요된다.
- INSERT, DELETE 시 많은 시간이 소요된다. (-> 클러스터 인덱스 성질처럼 다시 정렬된 상태를 유지해주거나, 페이지를 분할 작업이 함께 실행되기 때문에)(물론 생성, 삭제를 하기위한 데이터 조회는 인덱스를 활용한다면 빠르게 조회된다.)

#### 인덱스 설정할때 기준

|           기준           |            정도             |
| :----------------------: | :-------------------------: |
| 카디널리티 (Cardinality) |       높을 수록 적합        |
|   선택도 (Selectivity)   | 낮을 수록 적합 (5~10% 적정) |
|          활용도          |       높을 수록 적합        |
|          중복도          |       없을 수록 적합        |

- 카디널리티(=한 컬럼이 가질 수 있는 값의 개수)는 높을수록 좋다. (남자 여자처럼 2개로만 걸러지는 인덱스보다, 이름처럼 중복도가 낮은 인덱스가 데이터의 대부분을 걸러내기 때문에)
- 선택도(=데이터에서 특정값을 제대로 선택할 수 있는 비율)는 낮을 수록 적합하다. (```선택도 = 컬럼의 특정 값의 row 수 / 테이블의 총 row 수 * 100 = 컬럼의 값들의 평균 row 수 / 테이블의 총 row 수 * 100```)(말로 하자면, 전체 행에서 컬럼 값들의 평균 행의 비율을 말한다.)
- 활용도(=실제 작업에서 얼마나 활용되는지)는 높을 수록 적합하다. (간단히생각해봐도 만들어놓고 묵혀놓는 인덱스말고, 자주 불러서 활용될만한 인덱스를 설정하는 것이 낫다.)
- 중복도(=중복 인덱스 여부의 값)는 없을 수록 적합하다. (인덱스는 [일정 조건](https://www.fun-coding.org/mysql_advanced5.html)을 만족하면 같은 컬럼가지고 중복으로 인덱스를 설정할 수 있다.)(걍 같은 역할의 인덱스가 잘못 중복으로 생성하는 것은 메모리 낭비다는 것이다.)



## Reference

- https://itholic.github.io/database-index/ -> Index 비유법

- https://s1107.tistory.com/38 -> 간단 개념

- https://mee2ro.tistory.com/2 -> index 종류 비유

- https://s1107.tistory.com/38 -> 개념 다른 표현

- https://yurimkoo.github.io/db/2020/03/14/db-index.html -> 인덱스 설정시 고려사항

- https://mozi.tistory.com/199 -> 논 클러스터 인덱스의 종류(단일, 복합, 커버드) 

- https://lng1982.tistory.com/144 -> 인덱스 종류 비유

- https://mozi.tistory.com/320 -> 두 인덱스의 구조 순서대로 정리

- https://dev-navill.tistory.com/26 -> mysql 에서 인덱스 쓰는 법

- https://jojoldu.tistory.com/243 -> 역시 창천향로 

  

